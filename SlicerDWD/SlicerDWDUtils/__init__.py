import csv
import random
from collections import namedtuple
from typing import TextIO

import numpy as np
import scipy.stats
import slicer
import vtk
from vtk.numpy_interface import dataset_adapter as dsa


def load_cases(fp: TextIO):
    """Load a case CSV file generated by ShapeVariationAnalyzer.

    Expects the CSV to have two columns: Filename, Group.
    """

    reader = csv.reader(fp)
    return [(path, group) for path, group in reader]


def split_cases(cases, part=0.5):
    """Randomly split a list into two parts.

    part is a float between 0 and 1, indicating the relative size of the first part.
    """

    cases = cases.copy()
    random.shuffle(cases)
    idx = int(len(cases) * part)
    return cases[:idx], cases[idx:]


def read_vtk(path) -> dsa.PolyData:
    """Load a PolyData from a file"""

    reader = vtk.vtkPolyDataReader()
    reader.SetFileName(str(path))
    reader.Update()
    return dsa.WrapDataObject(reader.GetOutput())


def save_vtk(path, data: dsa.PolyData):
    """Save a PolyData to a file"""

    writer = vtk.vtkPolyDataWriter()
    writer.SetFileName(str(path))
    writer.SetInputData(data.VTKObject)
    writer.Update()


def copy_dsa(data: dsa.PolyData) -> dsa.PolyData:
    """Deep copy a PolyData"""

    res = dsa.WrapDataObject(vtk.vtkPolyData())
    res.VTKObject.DeepCopy(data.VTKObject)
    return res


def make_xy(cases):
    """Return X, y arrays used for training a model.

    X is a 2-dimensional numpy array of feature data.
    y is a 1-dimensional numpy array of classes.
    """

    X = np.array([read_vtk(path).Points.flatten() for path, group in cases])
    y = np.array([group for path, group in cases])
    return X, y


def direction(classifier):
    """Return the DWD direction and intercept. The separating hyperplane is of the
    form 'p.d = d.i', where '.' is the dot product. If 'p.d < d.i', then 'p' is label
    0. If 'p.d > d.i', then 'p' is label 1.
    """

    d = classifier.coef_.reshape(-1)
    i = -float(classifier.intercept_)
    return d, i


KDEResult = namedtuple('KDEResult', ['x', 'kernel', 'ulabels', 'kernels'])


def kde(data, labels=..., rescale=False):
    x = np.linspace(data.min(), data.max())
    kernel = scipy.stats.gaussian_kde(data)(x)

    if labels is ...:
        return x, kernel

    ulabels, counts = np.unique(labels, return_counts=True)

    if rescale:
        total = len(labels)
        factors = counts / total
    else:
        factors = np.ones_like(counts)

    kernels = [
        scipy.stats.gaussian_kde(data[labels == label])(x) * factor
        for label, factor in zip(ulabels, factors)
    ]

    return KDEResult(x, kernel, ulabels, kernels)


def make_table(name, **cols):
    tableNode = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLTableNode", name)
    tab = tableNode.GetTable()

    for col, data in cols.items():
        arr = vtk.util.numpy_support.numpy_to_vtk(data)
        arr.SetName(col)
        tab.AddColumn(arr)

    return tableNode


def make_series(
    name, table, x, y,
    plotType=slicer.vtkMRMLPlotSeriesNode.PlotTypeScatter,
    lineStyle=slicer.vtkMRMLPlotSeriesNode.LineStyleSolid,
    markerStyle=slicer.vtkMRMLPlotSeriesNode.MarkerStyleNone,
    color=(0, 0, 0),
):
    node = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLPlotSeriesNode", name)
    node.SetAndObserveTableNodeID(table.GetID())
    node.SetXColumnName(x)
    node.SetYColumnName(y)
    node.SetPlotType(plotType)
    node.SetLineStyle(lineStyle)
    node.SetMarkerStyle(markerStyle)
    node.SetColor(*color)
    return node
